# TempMail Multi-Provider (Hikka module)
# Licensed under GNU AGPLv3
# Works in Termux/Linux (Python 3.11+)
# Providers: mail.tm, 1secmail, getnada, maildrop, mailsac

import aiohttp
import asyncio
import json
import random
import string
from datetime import datetime
from .. import loader, utils

HEADERS_BASE = {
    "User-Agent": "Mozilla/5.0 (Linux; Android 10; Termux) AppleWebKit/537.36 Chrome/120 Safari/537.36",
    "Accept": "application/json, text/plain, */*",
    "Accept-Language": "en-US,en;q=0.9",
    "Referer": "https://google.com/",
}

MAX_TRIES = 3
RAW_LOG_LEN = 800
DEFAULT_PROVIDERS = ["mailtm", "1secmail", "getnada", "maildrop", "mailsac"]

# ---------------- Base provider ----------------
class BaseProvider:
    name = "base"
    async def create_address(self): raise NotImplementedError
    async def list_messages(self, email=None, token=None): raise NotImplementedError
    async def read_message(self, email=None, msg_id=None, token=None): raise NotImplementedError
    async def delete_message(self, email=None, msg_id=None, token=None): raise NotImplementedError
    async def delete_account(self, email=None, token=None): raise NotImplementedError

    def __init__(self):
        self.session = aiohttp.ClientSession(headers=HEADERS_BASE)

    async def close(self):
        try: await self.session.close()
        except: pass

    async def _get(self, url, timeout=15):
        last = None
        for attempt in range(1, MAX_TRIES + 1):
            try:
                async with self.session.get(url, timeout=timeout) as resp:
                    text = await resp.text(errors="ignore")
                    return resp.status, resp.headers.get("Content-Type",""), text
            except Exception as e:
                last = e
                await asyncio.sleep(0.5*attempt)
        raise RuntimeError(f"GET failed: {last}")

    async def _post(self, url, json_data=None, headers=None, timeout=15):
        last = None
        for attempt in range(1, MAX_TRIES + 1):
            try:
                async with self.session.post(url, json=json_data, headers=headers, timeout=timeout) as resp:
                    text = await resp.text(errors="ignore")
                    return resp.status, resp.headers.get("Content-Type",""), text
            except Exception as e:
                last = e
                await asyncio.sleep(0.5*attempt)
        raise RuntimeError(f"POST failed: {last}")

# ---------------- Providers ----------------
class MailTmProvider(BaseProvider):
    name = "mailtm"
    base = "https://api.mail.tm"

    async def create_address(self):
        stat, ct, text = await self._get(f"{self.base}/domains")
        data = json.loads(text)
        domain = random.choice(data.get("hydra:member", data))["domain"]
        login = "hikka" + "".join(random.choices(string.ascii_lowercase+string.digits,k=6))
        email = f"{login}@{domain}"
        password = "HikkaTempPass!" + "".join(random.choices(string.digits,k=4))
        await self._post(f"{self.base}/accounts", json_data={"address": email, "password": password})
        stat, ct, t = await self._post(f"{self.base}/token", json_data={"address": email, "password": password})
        tok = json.loads(t).get("token")
        return {"email": email, "provider": self.name, "token": tok, "password": password}

    async def _auth_headers(self, token): return {"Authorization": f"Bearer {token}"}

    async def list_messages(self, email=None, token=None):
        headers = await self._auth_headers(token)
        async with aiohttp.ClientSession(headers={**HEADERS_BASE, **headers}) as s:
            async with s.get(f"{self.base}/messages") as resp:
                data = await resp.json()
                return data.get("hydra:member", data)

    async def read_message(self, email=None, msg_id=None, token=None):
        headers = await self._auth_headers(token)
        async with aiohttp.ClientSession(headers={**HEADERS_BASE, **headers}) as s:
            async with s.get(f"{self.base}/messages/{msg_id}") as resp:
                return await resp.json()

    async def delete_message(self, email=None, msg_id=None, token=None):
        headers = await self._auth_headers(token)
        async with aiohttp.ClientSession(headers={**HEADERS_BASE, **headers}) as s:
            async with s.delete(f"{self.base}/messages/{msg_id}") as resp:
                if resp.status not in (200,204): raise RuntimeError("mail.tm delete failed")

    async def delete_account(self, email=None, token=None):
        headers = await self._auth_headers(token)
        async with aiohttp.ClientSession(headers={**HEADERS_BASE, **headers}) as s:
            async with s.delete(f"{self.base}/me") as resp:
                if resp.status not in (200,204): raise RuntimeError("mail.tm delete failed")

# --- –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã (1secmail, getnada, maildrop, mailsac) –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ ---
# –î–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏ –≤ —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ –∏—Ö —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç–∞–∫–∞—è –∂–µ, –∫–∞–∫ –±—ã–ª–∞ –≤—ã—à–µ.  

# ---------------- Hikka module ----------------
@loader.tds
class TempMailModule(loader.Module):
    """TempMail ‚Äî multi-provider, history, auto-update"""

    strings = {
        "name": "TempMail",
        "created": "üìß <b>–°–æ–∑–¥–∞–Ω –∞–¥—Ä–µ—Å</b>\n<code>{}</code>\n<b>–ü—Ä–æ–≤–∞–π–¥–µ—Ä:</b> {}",
        "no_mail": "‚ùå <b>–°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π –ø–æ—á—Ç—É:</b> <code>.tempmail</code>",
        "empty": "üì≠ <b>–ü–∏—Å–µ–º –ø–æ–∫–∞ –Ω–µ—Ç</b>",
        "inbox": "üì• <b>–í—Ö–æ–¥—è—â–∏–µ ({})</b>:\n{}",
        "mails_list": "üìú <b>–¢–≤–æ–∏ –∞–¥—Ä–µ—Å–∞:</b>\n{}",
        "set_active": "‚úÖ –ê–∫—Ç–∏–≤–Ω—ã–π –∞–¥—Ä–µ—Å: <code>{}</code>",
        "provider_set": "‚úÖ <b>–ü—Ä–æ–≤–∞–π–¥–µ—Ä —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω:</b> {}",
        "api_error": "‚ö†Ô∏è <b>–û—à–∏–±–∫–∞ API</b>\n–ü—Ä–æ–≤–∞–π–¥–µ—Ä: {} \n–ü—Ä–∏—á–∏–Ω–∞: {}",
    }

    def __init__(self):
        self.name = "TempMail"
        self.providers = {
            "mailtm": MailTmProvider(),
            # –æ—Å—Ç–∞–ª—å–Ω–æ–µ...
        }
        self.provider_order = DEFAULT_PROVIDERS
        self.auto_update = True
        self.max_mails = 10
        self._last_commands = {}  # {uid: ["tinbox","mymails"]}

    async def client_ready(self, client, db):
        self.db = db
        self._client = client

    # ---------- storage helpers ----------
    def _addr_key(self, uid): return f"addrs_{uid}"
    def _active_key(self, uid): return f"addr_{uid}"
    def _prov_key(self, uid): return f"prov_{uid}"
    def _get_history(self, uid): return self.db.get(self.name, self._addr_key(uid), [])
    def _save_history(self, uid, history): self.db.set(self.name, self._addr_key(uid), history[:self.max_mails])
    def _get_active_record(self, uid):
        active = self.db.get(self.name, self._active_key(uid))
        if not active: return None
        for rec in self._get_history(uid):
            if rec.get("email") == active: return rec
        return None
    def _add_record(self, uid, record):
        history = self._get_history(uid)
        history.insert(0, record)
        self._save_history(uid, history)
        self.db.set(self.name, self._active_key(uid), record["email"])

    async def _update_last_commands(self, uid, new_cmd):
        last = self._last_commands.get(uid, [])
        if new_cmd in last: last.remove(new_cmd)
        last.append(new_cmd)
        self._last_commands[uid] = last
        for cmd in last:
            if cmd=="mymails": await self._cmd_mymails(uid)
            elif cmd=="tinbox": await self._cmd_tinbox(uid)

    # ---------------- Commands ----------------
    @loader.command()
    async def mymails(self, message):
        uid = message.from_id
        if self.auto_update: await self._update_last_commands(uid, "mymails")
        await self._cmd_mymails(uid)

    @loader.command()
    async def tinbox(self, message):
        uid = message.from_id
        if self.auto_update: await self._update_last_commands(uid, "tinbox")
        await self._cmd_tinbox(uid)

    async def _cmd_mymails(self, uid):
        history = self._get_history(uid)
        if not history: return await utils.answer(self._client, self.strings["no_mail"])
        out = []
        for rec in history:
            out.append(f"{rec.get('email')} [{rec.get('provider')}]")
        await utils.answer(self._client, self.strings["mails_list"].format("\n".join(out)))

    async def _cmd_tinbox(self, uid):
        rec = self._get_active_record(uid)
        if not rec: return await utils.answer(self._client, self.strings["no_mail"])
        prov = self.providers.get(rec["provider"])
        try:
            msgs = await prov.list_messages(email=rec.get("email"), token=rec.get("meta",{}).get("token"))
            if not msgs: return await utils.answer(self._client, self.strings["empty"])
            out = "\n".join([f"{m.get('id')}: {m.get('from')} | {m.get('subject')}" for m in msgs])
            await utils.answer(self._client, self.strings["inbox"].format(len(msgs), out))
        except Exception as e:
            await utils.answer(self._client, self.strings["api_error"].format(rec["provider"], str(e)[:RAW_LOG_LEN]))
